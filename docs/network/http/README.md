---
title: HTTP
sidebar: auto
---

## HTTP

### HTTP 0.9、HTTP 1.0、HTTP 1.1、HTTP 2.0、HTTP 3.0 区别

- **HTTP 0.9**

  -  HTTP/0.9是第一个版本的HTTP协议，已过时。它的组成极其简单，只允许客户端发送GET这一种请求，且不支持请求头。由于没有协议头，造成了HTTP/0.9协议只支持一种内容，即纯文本。

- **HTTP 1.0**

  HTTP协议的第二个版本，第一个在通讯中指定版本号的HTTP协议版本，至今仍被广泛采用。相对于HTTP/0.9增加了如下主要特性：

  - 引入请求头和响应头
  - 引入状态码
  - 除了GET命令，还引入了POST命令和HEAD命令。
  - 支持长连接（但默认还是使用短连接），缓存机制，以及身份认证
  - 任何格式的内容都可以发送，这使得互联网不仅可以传输文字，还能传输图像、视频、二进制等文件。

- **HTTP 1.1**

  1. 默认为长连接

     HTTP 1.1支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，在HTTP1.1中默认开启Connection：keep-alive，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。

  2. 提供了范围请求功能(宽带优化)

     HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。这是支持文件断点续传的基础。

  3. 提供了虚拟主机的功能(HOST域)

     在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。

  4. 多了一些缓存处理字段

     HTTP/1.1在1.0的基础上加入了一些cache的新特性，引入了实体标签，一般被称为e-tags，新增更为强大的Cache-Control头。

  5. 错误通知的管理

     在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。

- **HTTP 2.0**

  1. 二进制分帧

     HTTP 2.0 的所有帧都采用二进制编码

     原来`Headers + Body`的报文格式如今被拆分成了一个个二进制的帧，用**Headers帧**存放头部字段，**Data帧**存放请求体数据。分帧之后，服务器看到的不再是一个个完整的 HTTP 请求报文，而是一堆乱序的二进制帧。这些二进制帧不存在先后关系，因此也就不会排队等待，也就没有了 HTTP 的队头阻塞问题。

  2. 多路复用

     多路复用允许同时通过单一的HTTP 2.0 连接发起多重的请求-响应消息。有了新的分帧机制后，HTTP 2.0不再依赖多个TCP 连接去处理更多并发的请求。每个数据流都拆分成很多互不依赖的帧，而这些帧可以交错（乱序发送），还可以分优先级。最后再在另一端根据每个帧首部的流标识符把它们重新组合起来。HTTP 2.0 连接都是持久化的，而且客户端与服务器之间也只需要一个连接（每个域名一个连接）即可。

  3. 头部压缩

     在 HTTP 2.0 中，使用了 HPACK（HTTP2头部压缩算法）压缩格式对传输的头部进行编码，减少了头部的大小。并在两端维护了索引表，用于记录出现过的头部，之后在传输过程中就可以传输已经记录过的头部健名，对端收到数据后就可以通过键名找到对应的值。

  4. 请求优先级

     浏览器可以在发现资源时立即分派请求，指定每个流的优先级，让服务器决定最优的响应次序。这样请求就不必排队了，既节省了时间，也最大限度地利用了每个连接。

  5. 服务端推送

     服务端推送能把客户端所需要的资源伴随着index.html一起发送到客户端，省去了客户端重复请求的步骤。正因为没有发起请求，建立连接等操作，所以静态资源通过服务端推送的方式可以极大地提升速度。

- **HTTP 3.0**

  ​	基于 `UDP` 实现的 **QUIC 协议**

  - **实现了类似 TCP 的流量控制、传输可靠性的功能**。
  - **集成了 TLS 加密功能**
  - **实现了 HTTP/2 中的多路复用功能**
  - **实现了快速握手功能**

### HTTP 优缺点

#### HTTP 特点

- <u>灵活可扩展</u>。一个是语法上只规定了基本格式，空格分隔单词，换行分隔字段等。另外一个就是传输形式上不仅可以传输文本，还可以传输图片，视频等任意数据。
- <u>请求-应答模式</u>，通常而言，就是一方发送消息，另外一方要接受消息，或者是做出相应等。
- <u>可靠传输</u>，HTTP是基于TCP/IP，因此把这一特性继承了下来。
- <u>无状态</u>，这里的状态是指**通信过程的上下文信息**，而每次 http 请求都是独立、无关的，默认不需要保留状态信息。

#### HTTP 缺点

- <u>无状态</u>，有时候，需要保存信息，比如像购物系统，需要保留下顾客信息等等，另外一方面，有时候，无状态也会减少网络开销，比如类似直播行业这样子等，这个还是分场景来说。
- <u>明文传输</u>，即协议里的报文(主要指的是头部)不使用二进制数据，而是文本形式。这让HTTP的报文信息暴露给了外界，给攻击者带来了便利。
- <u>队头阻塞</u>，当http开启长连接时，共用一个TCP连接，当某个请求时间过长时，其他的请求只能处于阻塞状态，这就是队头阻塞问题。

### HTTP 的请求方法

> `http/1.1`规定了以下请求方法(注意，都是大写):
>
> - **GET**: 通常用来获取资源
> - **HEAD**: 获取资源的元信息
> - **POST**: 提交数据，即上传数据
> - **PUT**: 修改数据
> - **DELETE**: 删除资源(几乎用不到)
> - **CONNECT**: 建立连接隧道，用于代理服务器
> - **OPTIONS**: 列出可对资源实行的请求方法，用来跨域请求
> - **TRACE**: 追踪请求-响应的传输路径

<u>**幂等性**，是指该方法多次调用返回的效果(形式)一致，客户端可以重复调用并且期望同样的结果。</u>

<u>如果HTTP方法不更改服务器状态，则认为它们是**安全**的。</u>

| 方法名  | 安全性 | 幂等性 |
| ------- | ------ | ------ |
| GET     | 是     | 是     |
| HEAD    | 是     | 是     |
| OPTIONS | 是     | 是     |
| DELETE  | 否     | 是     |
| PUT     | 否     | 是     |
| POST    | 否     | 否     |

### GET 和 POST 有什么区别？

首先最直观的是语义上的区别。

而后又有这样一些具体的差别:

| 区别内容                  | GET                                                          | POST                                                         |
| ------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 点击返回/刷新按钮         | 没有影响                                                     | 数据会重新发送（浏览器将会提示“数据被重新提交”）             |
| 添加书签                  | 可以                                                         | 不可以                                                       |
| 缓存                      | 可以                                                         | 不可以                                                       |
| 编码类型（Encoding type） | `application/x-www-form-rulencoded`                          | `application/x-www-form-rulencoded` or `multipart/form-data` 请为二进制数据使用 `multipart` 编码 |
| 历史记录                  | 有                                                           | 没有                                                         |
| 长度限制                  | 有                                                           | 没有                                                         |
| 数据类型限制              | 只允许 ASCLll 字符类型                                       | 没有限制，允许二进制数据                                     |
| 安全性                    | 查询字符串会显示在地址栏的 URL 上，不安全，**请不要使用 GET 请求提交敏感数据** | 因为数据不会显示在地址栏中，也不会缓存下来或保存在浏览记录中，所以 POST 请求比 GET 请求安全，但也不是最安全的方式，如需要传送敏感数据，**请使用数据加密**。 |
| 幂等性                    | 幂等                                                         | 非幂等                                                       |
| 可见性                    | 查询字符串在地址栏的 URL 中可见                              | 查询字符串在地址栏的 URL 中不可见                            |
| TCP                       | 请求会把请求报文一次性发出去                                 | 分为两个 TCP 数据包，首先发 header 部分，如果服务器响应 100(continue)， 然后发 body 部分(**火狐**浏览器除外，它的 POST 请求只发一个 TCP 包) |

### HTTP 状态码

>RFC 规定 HTTP 的状态码为**三位数**，被分为五类:
>
>- **1xx**: 表示目前是协议处理的中间状态，还需要后续操作。
>- **2xx**: 表示成功状态。
>- **3xx**: 重定向状态，资源位置发生变动，需要重新请求。
>- **4xx**: 请求报文有误。
>- **5xx**: 服务器端发生错误。

#### 1xx： 指示信息–表示请求已接收，继续处理

- <u>100</u> 客户必须继续发出请求
- <u>101 Switching Protocols</u>。客户要求服务器根据请求转换HTTP协议版本。

#### 2xx：成功–表示请求已被成功接收、理解、接受

- <u>200 OK</u> 表示从客户端发来的请求在服务器端被正确请求
- <u>204 No content</u>，表示请求成功，但没有资源可返回。
- <u>206 Partial Content</u>，该状态码表示客户端进行了范围请求，而服务器成功执行了这部分的 GET 请求 响应报文中包含由 **「Content-Range」** 指定范围的实体内容

#### 3xx：重定向–要完成请求必须进行更进一步的操作

- <u>301 Moved Permanently</u>，永久性重定向，表示资源已被分配了新的 URL，这时应该按 Location 首部字段提示的 URI 重新保存。（`301`浏览器会做缓存优化）

- <u>302 Found</u>，临时性重定向，表示资源临时被分配了新的 URL。

- <u>303 See Other</u>，表示资源存在着另一个 URL，应使用 GET 方法获取资源。

- <u>304 Not Modified</u>，当协商缓存命中时会返回这个状态码。

- <u>307 Temporary Redirect</u>，临时重定向，和`302`含义相同，不会改变method

  > 当 301、302、303 响应状态码返回时，几乎所有的浏览器都会把 POST 改成 GET，并删除请求报文内的主体，之后请求会自动再次发送 301、302 标准是禁止将 POST 方法改变成 GET 方法的，但实际使用时大家都会这么做

#### 4xx：客户端错误–请求有语法错误或请求无法实现

- <u>400 Bad Request</u>， 请求报文存在语法错误。
- <u>401 unauthorized</u>，表示发送的请求需要有通过 HTTP 认证的认证信息。
- <u>403 Forbidden</u>，表示对请求资源的访问被服务器拒绝。
- <u>404 Not Found</u>， 资源未找到，表示没在服务器上找到相应的资源。
- <u>405 Method Not Allowed</u>，请求方法不被服务器端允许。
- <u>406 Not Acceptable</u>， 资源无法满足客户端的条件。
- <u>408 Request Timeout</u>，服务器等待了太长时间。
- <u>409 Conflict</u>， 多个请求发生了冲突。
- <u>413 Request Entity Too Large</u>， 请求体的数据过大。
- <u>414 Request-URI Too Long</u>，请求行里的 URI 太大。
- <u>429 Too Many Request</u>，客户端发送的请求过多。
- <u>431 Request Header Fields Too Large</u>，请求头的字段内容太大。

#### 5xx：服务器端错误–服务器未能实现合法的请求

- <u>500 Internal Server Error</u>，表示服务器端在执行请求时发生了错误。
- <u>501 Not Implemented</u>，表示客户端请求的功能还不支持。
- <u>502 Bad Gateway</u>，服务器自身是正常的，但访问的时候出错了，啥错误咱也不知道。
- <u>503 Service Unavailable</u>， 表示服务器当前很忙，暂时无法响应服务。



### HTTPS 和 HTTP 区别

1. https 协议需要到 ca 申请证书，一般免费证书较少，因而需要一定费用。

2. http 是超文本传输协议，信息是明文传输， https 则是具有安全性的ssl加密传输协议。

3. http 和 https 使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。

4. http 的连接很简单，是无状态的； HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 http 协议安全。