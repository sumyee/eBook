---
title: 浏览器工作原理与实践
sidebar: auto

---

# 浏览器工作原理与实践

## 01| 仅仅打开了1个页面，为什么有4个进程？



**进程**：一个进程就是一个程序的运行实例（*详细解释就是，启动一个程序的时候，操作系统会为该程序创建一块内存，用来存放代码、运行中的数据和一个执行任务的主线程，我们把这样的一个运行环境叫**进程***）

**线程**：线程是不能单独存在的，它是由进程来启动和管理的

**并行处理**：计算机中的并行处理就是同一时刻处理多个任务



**进程和线程之间的关系：**

1. 进程中的任意一线程执行出错，都会导致整个进程的崩溃。

2. 线程之间共享进程中的数据。

3. 当一个进程关闭之后，操作系统会回收进程所占用的内存。

4. 进程之间的内容相互隔离。

   

 **Chrome 进程架构**：

![image.png](https://i.loli.net/2021/07/26/GftFOEdKhJ6e9ar.png)

- **浏览器进程**。主要负责界面显示、用户交互、子进程管理，同时提供存储等功能。
- **渲染进程**。核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页，排版引擎 Blink 和 JavaScript 引擎 V8 都是运行在该进程中，默认情况下，Chrome 会为每个 Tab 标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。
- **GPU 进程**。其实，Chrome 刚开始发布的时候是没有 GPU 进程的。而 GPU 的使用初衷是为了实现 3D CSS 的效果，只是随后网页、Chrome 的 UI 界面都选择采用 GPU 来绘制，这使得 GPU 成为浏览器普遍的需求。最后，Chrome 在其多进程架构上也引入了 GPU 进程。
- **网络进程**。主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，直至最近才独立出来，成为一个单独的进程。
- **插件进程**。主要是负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响。







## 02 | TCP协议：如何保证页面文件能被完整送达浏览器？

- **IP：把数据包送达目的主机**（网络层）

  ![image.png](https://i.loli.net/2021/07/26/fjCF59VmxBzYDoe.png)

- **UDP：把数据包送达应用程序**（传输层）

  1. 用户数据包协议（User Datagram Protocol）

  2. UDP 中一个最重要的信息是**端口号**，IP 通过 IP 地址信息把数据包发送给指定的电脑，而 UDP 通过**端口号**把数据包分发给正确的程序

     ![image.png](https://i.loli.net/2021/07/26/5JQ23BtmGfszCy6.png)

- **TCP：把数据完整地送达应用程序**（传输层）

  1. TCP（Transmission Control Protocol，传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议

     - 对于数据包丢失的情况，TCP 提供重传机制；
     - TCP 引入了数据包排序机制，用来保证把乱序的数据包组合成一个完整的文件。

     *和 UDP 头一样，TCP 头除了包含了目标端口和本机端口号外，还提供了用于排序的序列号，以便接收端通过序号来重排数据包。*

  ![image.png](https://i.loli.net/2021/07/26/EbQsGf2arUmZI7n.png)





**一个完整的 TCP 连接的生命周期包括了“建立连接”“传输数据”和“断开连接”三个阶段**

- **首先，建立连接阶段**。这个阶段是通过“三次握手”来建立客户端和服务器之间的连接。TCP 提供面向连接的通信传输。**面向连接**是指在数据通信开始之前先做好两端之间的准备工作。所谓**三次握手**，是指在建立一个 TCP 连接时，客户端和服务器总共要发送三个数据包以确认连接的建立。
- **其次，传输数据阶段**。在该阶段，**接收端需要对每个数据包进行确认操作**，也就是接收端在接收到数据包之后，需要发送确认数据包给发送端。所以当发送端发送了一个数据包之后，在规定时间内没有接收到接收端反馈的确认消息，则判断为数据包丢失，并触发发送端的重发机制。同样，一个大的文件在传输过程中会被拆分成很多小的数据包，这些数据包到达接收端后，接收端会按照 TCP 头中的序号为其排序，从而保证组成完整的数据。
- **最后，断开连接阶段**。数据传输完毕之后，就要终止连接了，涉及到最后一个阶段“四次挥手”来保证双方都能断开连接。

![image.png](https://i.loli.net/2021/07/26/QMpGOkh5NIiuwWq.png)







## 03 | HTTP请求流程：为什么很多站点第二次打开速度会很快？

**浏览器端发起 HTTP 请求流程**：

1. 构建请求
2. 查找缓存
3. 准备 IP 地址和端口
4. 等待 TCP 队列
5. 建立 TCP 连接
6. 发送 HTTP 请求

**服务器端处理 HTTP 请求流程**：

1. 返回请求

2. 断开连接

3. 重定向

   

**HTTP 请求流程示意图**

![image.png](https://i.loli.net/2021/07/26/bYHD6nVZoISOz3X.png)







## 04 | 导航流程：从输入URL到页面展示，这中间发生了什么？

**从输入 URL 到页面展示完整流程示意图**：

![image.png](https://i.loli.net/2021/07/26/QJ1ZwdGijWx7Mfo.png)

- 首先，用户从浏览器进程里**输入请求信息**；
- 然后，网络进程**发起 URL 请求**；
- 服务器响应 URL 请求之后，浏览器进程就又要开始**准备渲染进程**了；
- 渲染进程准备好之后，需要先向渲染进程提交页面数据，我们称之为**提交文档**阶段；
- 渲染进程接收完文档信息之后，便开始**解析页面和加载子资源**，完成页面的渲染。







## 05 | 渲染流程（上）：HTML、CSS和JavaScript，是如何变成页面的？

1. **构建 DOM 树**

![0](https://i.loli.net/2021/07/26/6W9NaEbDAKOVLsj.png)

2. **样式计算**

   1. 把 CSS 转换为浏览器能够理解的结构

      ![下载 (1)](https://i.loli.net/2021/07/26/2y6iuza4EtT3Y9s.png)

      

   2. 转换样式表中的属性值，使其标准化

      ![下载 (2)](https://i.loli.net/2021/07/26/FzMeHunvlibWxGI.png)

      

   3. 计算出 DOM 树中每个节点的具体样式

      ![下载 (3)](https://i.loli.net/2021/07/26/Z8XW6xbchDY5nSf.png)

3. **布局阶段**

   1. 创建布局树

      1. 遍历 DOM 树中的所有可见节点，并把这些节点加到布局中；
      2. 而不可见的节点会被布局树忽略掉，如 head 标签下面的全部内容，再比如 body.p.span 这个元素，因为它的属性包含 dispaly:none，所以这个元素也没有被包进布局树。

      ![下载 (4)](https://i.loli.net/2021/07/26/q7QRNCjtS9DAiue.png)

   2. 布局计算

      ...







## 06 | 渲染流程（下）：HTML、CSS和JavaScript，是如何变成页面的？

渲染流程：

1. 渲染进程将 HTML 内容转换为能够读懂的**DOM 树**结构。
2. 渲染引擎将 CSS 样式表转化为浏览器可以理解的**styleSheets**，计算出 DOM 节点的样式。
3. 创建**布局树**，并计算元素的布局信息。
4. 对布局树进行分层，并生成**分层树**。
5. 为每个图层生成**绘制列表**，并将其提交到合成线程。
6. 合成线程将图层分成**图块**，并在**光栅化线程池**中将图块转换成位图。
7. 合成线程发送绘制图块命令**DrawQuad**给浏览器进程。
8. 浏览器进程根据 DrawQuad 消息**生成页面**，并**显示**到显示器上。

![image.png](https://i.loli.net/2021/07/26/nyAqBamTpGjzc5W.png)

- **重排：更新了元素的几何属性**

  ![image.png](https://i.loli.net/2021/07/26/x5Vzoc7APYj4E9U.png)

- **重绘：更新元素的绘制属性**

  ![image.png](https://i.loli.net/2021/07/26/CB6oDpsiLmNUrPu.png)

- **合成：更改一个既不要布局也不要绘制的属性，渲染引擎跳过布局和绘制，只执行后续的合成操作**

  ![image.png](https://i.loli.net/2021/07/26/iSj57xGBmXu3Yod.png)









## 07 | 变量提升：JavaScript代码是按顺序执行的吗？

> JavaScript 代码在执行之前需要被 JavaScript 引擎编译，**编译**完成之后，才会进入**执行**阶段。

**JavaScript 代码的执行流程**：

1. **编译阶段**

   输入一段代码，经过编译后，会生成两部分内容：**执行上下文（Execution context）和可执行代码**。

   **执行上下文是 JavaScript 执行一段代码时的运行环境**（比如调用一个函数，就会进入这个函数的执行上下文，确定该函数在执行期间用到的诸如 this、变量、对象以及函数等）

![下载 (5)](https://i.loli.net/2021/07/26/zuLNGDqApa1UWbK.png)

2. **执行阶段**

   JavaScript 引擎开始执行“可执行代码”，按照顺序一行一行地执行。

> 1. 编译是把代码拿过来创建执行上下文，并创建变量环境、词法环境、可执行代码，将执行上下文压入执行栈。
> 2. 执行是在当前执行上下文环境下执行可执行代码。
>
> - **变量环境**：通过var声明或function(){}声明的变量存在这里
> - **词法环境**：通过let、const、with()、 try-catch创建的变量存在这里
> - <u>可执行代码</u>：变量声明提前后，剩下的代码



## 08 | 调用栈：为什么JavaScript代码会出现栈溢出？

**总结：**

- 每调用一个函数，JavaScript 引擎会为其创建执行上下文，并把该执行上下文压入调用栈，然后 JavaScript 引擎开始执行函数代码。
- 如果在一个函数 A 中调用了另外一个函数 B，那么 JavaScript 引擎会为 B 函数创建执行上下文，并将 B 函数的执行上下文压入栈顶。
- 当前函数执行完毕后，JavaScript 引擎会将该函数的执行上下文弹出栈。
- 当分配的调用栈空间被占满时，会引发“堆栈溢出”问题。







## 09 | 块级作用域：var缺陷以及为什么要引入let和const？

**<u>作用域（scope）</u>**：作用域就是变量与函数的可访问范围，即作用域控制着变量和函数的可见性和生命周期。

在 ES6 之前，ES 的作用域只有两种：**全局作用域**和**函数作用域**。

- **全局作用域**中的对象在代码中的任何地方都能访问，其生命周期伴随着页面的生命周期。
- **函数作用域**就是在函数内部定义的变量或者函数，并且定义的变量或者函数只能在函数内部被访问。函数执行结束之后，函数内部定义的变量会被销毁。

<u>ES6 是支持块级作用域的，当执行到代码块时，如果代码块中有 let 或者 const 声明的变量，那么变量就会存放到该函数的**词法环境**中。</u>

**词法环境的结构和工作机制**：块级作用域就是通过词法环境的栈结构来实现的，而变量提升是通过变量环境来实现，通过这两者的结合，JavaScript 引擎也就同时支持了变量提升和块级作用域了。







## 10 | 作用域链和闭包 ：代码中出现相同的变量，JavaScript引擎是如何选择的？

**<u>词法作用域</u>**：词法作用域就是指作用域是由代码中函数声明的位置来决定的，所以词法作用域是静态的作用域，通过它就能够预测代码在执行过程中如何查找标识符。

**<u>动态作用域</u>**：在函数调用时确定的（**<u>JavaScript没有动态作用域概念</u>**）



- 因为 JavaScript 采用的是词法作用域，函数的作用域在函数定义的时候就决定了。

- 而与词法作用域相对的是动态作用域，函数的作用域是在函数调用的时候才决定的。

  

> 既不是形参也不是函数内部定义的局部变量的变量即**自由变量**。形参或函数内部定义的局部变量即**约束变量**。

> JavaScript 作用域链是由词法作用域决定的
>
> <u>词法作用域是代码阶段就决定好的，和函数是怎么调用的没有关系。</u>

**<u>闭包</u>**：在 JavaScript 中，根据词法作用域的规则，内部函数总是可以访问其外部函数中声明的变量，当通过调用一个外部函数返回一个内部函数后，即使该外部函数已经执行结束了，但是内部函数引用外部函数的变量依然保存在内存中，我们就把这些变量的集合称为闭包。





## 11 | this：从JavaScript执行上下文的视角讲清楚this

> ES6 中的箭头函数并不会创建其自身的执行上下文，所以箭头函数中的 this 取决于它的外部函数。
>
> this 的 4 种绑定规则分别是：`默认绑定`（直接调用）、`隐式绑定`（对象调用）、`显式绑定`（call、apply、bind）、`new 绑定`。<u>优先级从低到高</u>。

1. 当函数作为对象的方法调用时，函数中的 this 就是该对象；
2. 当函数被正常调用时，在严格模式下，this 值是 undefined，非严格模式下 this 指向的是全局对象 window；
3. 嵌套函数中的 this 不会继承外层函数的 this 值。

<u>**this** 就是函数运行时所在的环境对象（箭头函数中 **this** 就是定义时所在的对象）， **this** 的最终指向是那个调用它的对象</u>





## 12 | 栈空间和堆空间：数据是如何存储的？

**JavaScript 是一种弱类型的、动态的语言**

- **弱类型**，意味着你不需要告诉 JavaScript 引擎这个或那个变量是什么数据类型，JavaScript 引擎在运行代码的时候自己会计算出来。
- **动态**，意味着你可以使用同一个变量保存不同类型的数据。

**在运行过程中需要检查数据类型的语言称为动态语言**

**支持隐式类型转换的语言称为弱类型语言，不支持隐式类型转换的语言称为强类型语言**

<img src="https://i.loli.net/2021/07/27/sfyZdLtDQAlFH3e.png" alt="image.png"  />



在 JavaScript 的执行过程中， 主要有三种类型内存空间，分别是**代码空间、栈空间**和**堆空间**。

<img src="https://i.loli.net/2021/07/27/qwNMG4BbxafKz1c.png" alt="image.png"  />

**通常情况下，栈空间都不会设置太大，主要用来存放一些原始类型的小数据**。而引用类型的数据占用的空间都比较大，所以这一类数据会被存放到堆中，**堆空间很大，能存放很多大的数据**，不过缺点是分配内存和回收内存都会占用一定的时间。

**原始类型的赋值会完整复制变量值，而引用类型的赋值是复制引用地址**。

> 产生闭包的核心有两步：
>
> 1. 需要预扫描内部函数；
> 2. 把内部函数引用的外部变量保存到堆中。
>
> **<u>*闭包保存在堆内存中*</u>**





## 13 | 垃圾回收：垃圾数据是如何自动回收的？

```js
function foo(){
    var a = 1
    var b = {name:" 极客邦 "}
    function showName(){
        var c = " 极客时间 "
        var d = {name:" 极客时间 "}
        }
    showName()
}
foo()
```



**调用栈中的数据是如何回收的**：

JavaScript 引擎会通过向下移动 ESP（<u>记录当前执行状态的指针称为 ESP</u>） 来销毁该函数保存在栈中的执行上下文。

![image.png](https://i.loli.net/2021/07/27/ZQhGNkdDPwKLfUr.png)





**堆中的数据是如何回收的**：

V8 中会把堆分为**新生代**和**老生代**两个区域，**新生代中存放的是生存时间短的对象，老生代中存放的生存时间久的对象**。

新生区通常只支持 1～8M 的容量，而老生区支持的容量就大很多了。对于这两块区域，V8 分别使用两个不同的垃圾回收器，以便更高效地实施垃圾回收。

- **副垃圾回收器，主要负责新生代的垃圾回收。**
- **主垃圾回收器，主要负责老生代的垃圾回收。**



**垃圾回收器的工作流程**：

1. 第一步是**标记**空间中**活动对象**和**非活动对象**。所谓活动对象就是还在使用的对象，非活动对象就是可以进行垃圾回收的对象。
2. 第二步是**回收**<u>非活动对象</u>所占据的内存。其实就是在所有的标记完成之后，统一清理内存中所有被标记为可回收的对象。
3. 第三步是做**内存整理**。一般来说，频繁回收对象后，内存中就会存在大量不连续空间，我们把这些不连续的内存空间称为**内存碎片**。当内存中出现了大量的内存碎片之后，如果需要分配较大连续内存的时候，就有可能出现内存不足的情况。所以最后一步需要整理这些内存碎片，但这步其实是可选的，因为有的垃圾回收器不会产生内存碎片，比如接下来我们要介绍的副垃圾回收器。

**副垃圾回收器**：

副垃圾回收器主要负责新生区的垃圾回收。而通常情况下，大多数小的对象都会被分配到新生区，所以说这个区域虽然不大，但是垃圾回收还是比较频繁的。

新生代中用**Scavenge 算法**来处理。所谓 Scavenge 算法，是把新生代空间对半划分为两个区域，一半是对象区域，一半是空闲区域，如下图所示：

![image.png](https://i.loli.net/2021/07/27/L49OtY8FK35uJGT.png)

新加入的对象都会存放到对象区域，当对象区域快被写满时，就需要执行一次垃圾清理操作。

在垃圾回收过程中，首先要对对象区域中的垃圾做标记；标记完成之后，就进入垃圾清理阶段，副垃圾回收器会把这些存活的对象（<u>存活的标准就是引用计数</u>）复制到空闲区域中，同时它还会把这些对象有序地排列起来，所以这个复制过程，也就相当于完成了内存整理操作，复制后空闲区域就没有内存碎片了。

完成复制后，对象区域与空闲区域进行角色翻转，也就是原来的对象区域变成空闲区域，原来的空闲区域变成了对象区域。这样就完成了垃圾对象的回收操作，同时这种**角色翻转的操作还能让新生代中的这两块区域无限重复使用下去**。

由于新生代中采用的 Scavenge 算法，所以每次执行清理操作时，都需要将存活的对象从对象区域复制到空闲区域。但复制操作需要时间成本，如果新生区空间设置得太大了，那么每次清理的时间就会过久，所以**为了执行效率，一般新生区的空间会被设置得比较小**。

也正是因为新生区的空间不大，所以很容易被存活的对象装满整个区域。为了解决这个问题，JavaScript 引擎采用了**对象晋升策略**，也就是<u>经过两次垃圾回收依然还存活的对象，会被移动到老生区中</u>。



**主垃圾回收器**：

主垃圾回收器主要负责老生区中的垃圾回收。除了新生区中晋升的对象，一些大的对象会直接被分配到老生区。因此老生区中的对象有两个特点，一个是对象占用空间大，另一个是对象存活时间长。

由于老生区的对象比较大，若要在老生区中使用 Scavenge 算法进行垃圾回收，复制这些大的对象将会花费比较多的时间，从而导致回收执行效率不高，同时还会浪费一半的空间。因而，主垃圾回收器是采用<u>标记 - 清除（Mark-Sweep）</u>的算法进行垃圾回收的。下面我们来看看该算法是如何工作的。

首先是标记过程阶段。标记阶段就是从一组根元素开始，递归遍历这组根元素，在这个遍历过程中，能到达的元素称为**活动对象**，没有到达的元素就可以判断为**垃圾数据**。



比如最开始的那段代码，当 showName 函数执行退出之后，这段代码的调用栈和堆空间如下图所示：

![image.png](https://i.loli.net/2021/07/27/hTG4sOo3VC7uHDZ.png)

从上图你可以大致看到垃圾数据的标记过程，当 showName 函数执行结束之后，ESP 向下移动，指向了 foo 函数的执行上下文，这时候如果遍历调用栈，是不会找到引用 1003 地址的变量，也就意味着 1003 这块数据为垃圾数据，被标记为红色。由于 1050 这块数据被变量 b 引用了，所以这块数据会被标记为活动对象。这就是大致的标记过程。

接下来就是垃圾的清除过程。它和副垃圾回收器的垃圾清除过程完全不同，你可以理解这个过程是清除掉红色标记数据的过程，可参考下图大致理解下其清除过程：

![image.png](https://i.loli.net/2021/07/27/EYjrPHy3c6qgXnG.png)

上面的标记过程和清除过程就是标记 - 清除算法，不过对一块内存多次执行标记 - 清除算法后，会产生大量不连续的内存碎片。而碎片过多会导致大对象无法分配到足够的连续内存，于是又产生了另外一种算法——<u>标记 - 整理（Mark-Compact）</u>，这个标记过程仍然与标记 - 清除算法里的是一样的，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。你可以参考下图：

![image.png](https://i.loli.net/2021/07/27/kdwoXHOAP1LWcDr.png)

**全停顿**

现在你知道了 V8 是使用副垃圾回收器和主垃圾回收器处理垃圾回收的，不过由于 JavaScript 是运行在主线程之上的，一旦执行垃圾回收算法，都需要将正在执行的 JavaScript 脚本暂停下来，待垃圾回收完毕后再恢复脚本执行。我们把这种行为叫做**全停顿（Stop-The-World）**。

比如堆中的数据有 1.5GB，V8 实现一次完整的垃圾回收需要 1 秒以上的时间，这也是由于垃圾回收而引起 JavaScript 线程暂停执行的时间，若是这样的时间花销，那么应用的性能和响应能力都会直线下降。主垃圾回收器执行一次完整的垃圾回收流程如下图所示：

![image.png](https://i.loli.net/2021/07/27/A41Esvbk8pM6XwI.png)

在 V8 新生代的垃圾回收中，因其空间较小，且存活对象较少，所以全停顿的影响不大，但老生代就不一样了。如果在执行垃圾回收的过程中，占用主线程时间过久，就像上面图片展示的那样，花费了 200 毫秒，在这 200 毫秒内，主线程是不能做其他事情的。比如页面正在执行一个 JavaScript 动画，因为垃圾回收器在工作，就会导致这个动画在这 200 毫秒内无法执行的，这将会造成页面的卡顿现象。

为了降低老生代的垃圾回收而造成的卡顿，V8 将标记过程分为一个个的子标记过程，同时让垃圾回收标记和 JavaScript 应用逻辑交替进行，直到标记阶段完成，我们把这个算法称为**增量标记（Incremental Marking）算法**。如下图所示：

![image.png](https://i.loli.net/2021/07/27/GJnlpUI26fVXqhC.png)

使用增量标记算法，可以把一个完整的垃圾回收任务拆分为很多小的任务，这些小的任务执行时间比较短，可以穿插在其他的 JavaScript 任务中间执行，这样当执行上述动画效果时，就不会让用户因为垃圾回收任务而感受到页面的卡顿了。





## 14 | 编译器和解释器：V8是如何执行一段JavaScript代码的？

V8 执行一段代码流程图：

![image.png](https://i.loli.net/2021/07/27/dCZ7bwlBT5oX39a.png)

1. **生成抽象语法树（AST）和执行上下文**

   - **第一阶段是分词（tokenize），又称为词法分析**，其作用是将一行行的源码拆解成一个个 token。所谓**token**，指的是语法上不可能再分的、最小的单个字符或字符串。你可以参考下图来更好地理解什么 token。

     ![image.png](https://i.loli.net/2021/07/27/CNwujsb7VRnPgeO.png)

   - **第二阶段是解析（parse），又称为语法分析**，其作用是将上一步生成的 token 数据，根据语法规则转为 AST。如果源码符合语法规则，这一步就会顺利完成。但如果源码存在语法错误，这一步就会终止，并抛出一个“语法错误”。

   <u>AST 的生成过程，先分词，再解析</u>

   

2. **生成字节码**

   <u>字节码就是介于 AST 和机器码之间的一种代码。但是与特定类型的机器码无关，字节码需要通过解释器将其转换为机器码后才能执行。</u>

   

3. **执行代码**

   通常，如果有一段第一次执行的字节码，`解释器 Ignition` 会逐条解释执行。在执行字节码的过程中，如果发现有`热点代码（HotSpot）`，比如一段代码被重复执行多次，这种就称为`热点代码`，那么后台的`编译器 TurboFan` 就会把该段热点的字节码编译为高效的机器码，然后当再次执行这段被优化的代码时，只需要执行编译后的机器码就可以了，这样就大大提升了代码的执行效率。

**即时编译（JIT）**：

​	指解释器 Ignition 在解释执行字节码的同时，收集代码信息，当它发现某一部分代码变热了之后，TurboFan 编	译器便闪亮登场，把热点的字节码转换为机器码，并把转换后的机器码保存起来，以备下次使用。

​	![image.png](https://i.loli.net/2021/07/27/Y7OXivgnHL6bRuN.png)





## 15 | 消息队列和事件循环：页面是怎么“活”起来的？

消息队列：**消息队列是一种数据结构，可以存放要执行的任务**。它符合队列“**先进先出**”的特点，也就是说<u>要添加任务的话，添加到队列的尾部；要取出任务的话，从队列头部去取。</u>

![image.png](https://i.loli.net/2021/07/28/smXcuq4iQfEHtpR.png)





## 16 | WebAPI：setTimeout是如何实现的？

- **如果 setTimeout 存在嵌套调用，那么系统会设置最短时间间隔为 4 毫秒**
- **未激活的页面，setTimeout 执行最小间隔是 1000 毫秒**
- **延时执行时间有最大值**(如果 setTimeout 设置的延迟值大于 2147483647 毫秒（大约 24.8 天）时就会溢出，这导致定时器会被立即执行)





## 17 | WebAPI：XMLHttpRequest是怎么实现的？

**XMLHttpRequest 运作机制**：

![image.png](https://i.loli.net/2021/07/28/BQylgYtzcNPGvV7.png)

```js
function GetWebData(URL){
    /**
         * 1: 新建 XMLHttpRequest 请求对象
         */
    let xhr = new XMLHttpRequest()

    /**
         * 2: 注册相关事件回调处理函数 
         */
    xhr.onreadystatechange = function () {
        switch(xhr.readyState){
            case 0: // 请求未初始化
                console.log(" 请求未初始化 ")
                break;
            case 1://OPENED
                console.log("OPENED")
                break;
            case 2://HEADERS_RECEIVED
                console.log("HEADERS_RECEIVED")
                break;
            case 3://LOADING  
                console.log("LOADING")
                break;
            case 4://DONE
                if(this.status == 200||this.status == 304){
                    console.log(this.responseText);
                }
                console.log("DONE")
                break;
        }
    }

    xhr.ontimeout = function(e) { console.log('ontimeout') }
    xhr.onerror = function(e) { console.log('onerror') }

    /**
         * 3: 打开请求
         */
    xhr.open('Get', URL, true);// 创建一个 Get 请求, 采用异步


    /**
         * 4: 配置参数
         */
    xhr.timeout = 3000 // 设置 xhr 请求的超时时间
    xhr.responseType = "text" // 设置响应返回的数据格式
    xhr.setRequestHeader("X_TEST","time.geekbang")

    /**
         * 5: 发送请求
         */
    xhr.send();
}
```



## 18 | 宏任务和微任务：不是所有任务都是一个待遇

**宏任务**：

页面中的大部分任务都是在主线程上执行的，这些任务包括了：

- 渲染事件（如解析 DOM、计算布局、绘制）；
- 用户交互事件（如鼠标点击、滚动页面、放大缩小等）；
- JavaScript 脚本执行事件；
- 网络请求完成、文件读写完成事件。



**微任务**：

微任务就是一个需要异步执行的函数，执行时机是在主函数执行结束之后、当前宏任务结束之前。

当 JavaScript 执行一段脚本的时候，V8 会为其创建一个全局执行上下文，在创建全局执行上下文的同时，V8 引擎也会在内部创建一个**微任务队列**。

<u>如果在执行微任务的过程中，产生了新的微任务，同样会将该微任务添加到微任务队列中，V8 引擎一直循环执行微任务队列中的任务，直到队列为空才算执行结束。也就是说**在执行微任务过程中产生的新的微任务并不会推迟到下个宏任务中执行，而是在当前的宏任务中继续执行**。</u>

- 微任务和宏任务是绑定的，<u>每个宏任务在执行时，会创建自己的微任务队列</u>。
- <u>微任务的执行时长会影响到当前宏任务的时长</u>。比如一个宏任务在执行过程中，产生了 100 个微任务，执行每个微任务的时间是 10 毫秒，那么执行这 100 个微任务的时间就是 1000 毫秒，也可以说这 100 个微任务让宏任务的执行时间延长了 1000 毫秒。所以你在写代码的时候一定要注意控制微任务的执行时长。
- 在一个宏任务中，分别创建一个用于回调的宏任务和微任务，<u>无论什么情况下，微任务都早于宏任务执行</u>。





## 19 | Promise：使用Promise，告别回调函数

## 20 | async/await：使用同步的方式去写异步代码

**<u>生成器</u>函数是一个带星号函数，而且是可以暂停执行和恢复执行的**

1. 在生成器函数内部执行一段代码，如果遇到 yield 关键字，那么 JavaScript 引擎将返回关键字后面的内容给外部，并暂停该函数的执行。

2. 外部函数可以通过 next 方法恢复函数的执行。

   

**<u>协程</u>是一种比线程更加轻量级的存在(完全是由程序所控制)**。你可以把协程看成是跑在线程上的任务，一个线程上可以存在多个协程，但是<u>在线程上同时只能执行一个协程</u>，比如当前执行的是 A 协程，要启动 B 协程，那么 A 协程就需要将主线程的控制权交给 B 协程，这就体现在 A 协程暂停执行，B 协程恢复执行；同样，也可以从 B 协程中启动 A 协程。通常，**如果从 A 协程启动 B 协程，我们就把 A 协程称为 B 协程的父协程**。

1. **async**

   async 是一个通过<u>异步执行</u>并<u>隐式返回 Promise</u> 作为结果的函数。

2. **await**

   当执行到`await`时，会默认创建一个 Promise 对象



## 21 | Chrome开发者工具：利用网络面板做性能分析

**TTFB**：

**第一字节时间**（TTFB）是指从浏览器请求页面到从浏览器接收来自服务器发送的信息的第一个字节的时间。这一次包括DNS查找和使用（三次）[TCP](https://developer.mozilla.org/en-US/docs/Glossary/TCP)握手和[SSL](https://developer.mozilla.org/en-US/docs/Glossary/SSL)握手建立连接（如果请求是通过[https](https://developer.mozilla.org/zh-CN/docs/Glossary/https)发出的）。

**优化时间线上耗时项**：

1. **排队（Queuing）时间过久**

   排队时间过久，大概率是由浏览器为每个域名最多维护 6 个连接导致的。那么基于这个原因，你就可以让 1 个站点下面的资源放在多个域名下面，比如放到 3 个域名下面，这样就可以同时支持 18 个连接了，这种方案称为<u>域名分片</u>技术。除了域名分片技术外，我个人还建议你<u>把站点升级到 HTTP2</u>，因为 HTTP2 已经没有每个域名最多维护 6 个 TCP 连接的限制了。

2. **第一字节时间（TTFB）时间过久**

   这可能的原因有如下：

- <u>服务器生成页面数据的时间过久</u>。对于动态网页来说，服务器收到用户打开一个页面的请求时，首先要从数据库中读取该页面需要的数据，然后把这些数据传入到模板中，模板渲染后，再返回给用户。服务器在处理这个数据的过程中，可能某个环节会出问题。

- <u>网络的原因</u>。比如使用了低带宽的服务器，或者本来用的是电信的服务器，可联通的网络用户要来访问你的服务器，这样也会拖慢网速。

- <u>发送请求头时带上了多余的用户信息</u>。比如一些不必要的 Cookie 信息，服务器接收到这些 Cookie 信息之后可能需要对每一项都做处理，这样就加大了服务器的处理时长。

  对于这三种问题，你要有针对性地出一些解决方案。面对第一种服务器的问题，你可以想办法去提高服务器的处理速度，比如通过增加各种缓存的技术；针对第二种网络问题，你可以使用 CDN 来缓存一些静态文件；至于第三种，你在发送请求时就去尽可能地减少一些不必要的 Cookie 数据信息。

3. **Content Download 时间过久**

   如果单个请求的 Content Download 花费了大量时间，有可能是字节数太多的原因导致的。这时候你就需要减少文件大小，比如压缩、去掉源码中不必要的注释等方法。





## 22 | DOM树：JavaScript是如何影响DOM树构建的？

**什么是 DOM**：

- 从页面的视角来看，DOM 是生成页面的基础数据结构。
- 从 JavaScript 脚本视角来看，DOM 提供给 JavaScript 脚本操作的接口，通过这套接口，JavaScript 可以对 DOM 结构进行访问，从而改变文档的结构、样式和内容。
- 从安全视角来看，DOM 是一道安全防护线，一些不安全的内容在 DOM 解析阶段就被拒之门外了。

<u>简言之，DOM 是表述 HTML 的内部数据结构，它会将 Web 页面和 JavaScript 脚本连接起来，并过滤一些不安全的内容。</u>

**网络进程加载了多少数据，HTML 解析器便解析多少数据**。

**DOM 树如何生成**：

<u>网络进程加载了多少数据，HTML 解析器便解析多少数据。</u>

1. 第一个阶段，通过分词器将字节流转换为 Token。
2. 至于后续的第二个和第三个阶段是同步进行的，需要将 Token 解析为 DOM 节点，并将 DOM 节点添加到 DOM 树中。

**预解析操作**：当渲染引擎收到字节流之后，会开启一个预解析线程，用来分析 HTML 文件中包含的 JavaScript、CSS 等相关文件，解析到相关文件之后，预解析线程会提前下载这些文件。

**async**： async 标志的脚本文件一旦加载完成，会立即执行

**defer**：defer 标记的脚本文件，需要在 DOMContentLoaded 事件之前执行。

<u>JavaScript 会阻塞 DOM 生成，而样式文件又会阻塞 JavaScript 的执行</u>





## 23 | 渲染流水线：CSS如何影响首次加载时的白屏时间？

1. 

```css
/* theme.css */
div{ 
    color : coral;
    background-color:black
}
```

```html
<html>
    <head>
        <link href="theme.css" rel="stylesheet">
    </head>
    <body>
        <div>geekbang com</div>
    </body>
</html>
```

对于上面的代码，预解析线程会解析出来一个外部的 theme.css 文件，并发起 theme.css 的下载。这里也有一个空闲时间需要你注意一下，就是在 DOM 构建结束之后、theme.css 文件还未下载完成的这段时间内，渲染流水线无事可做，因为下一步是合成布局树，而合成布局树需要 CSSOM 和 DOM，所以这里需要等待 CSS 加载结束并解析成 CSSOM。

流水线示意图：

![image.png](https://i.loli.net/2021/07/29/iDcQJkNaCKS8uYf.png)



2. 

   ```css
   /* theme.css */
   div{ 
       color : coral;
       background-color:black
   }
   ```

   ```html
   <html>
       <head>
           <link href="theme.css" rel="stylesheet">
       </head>
       <body>
           <div>geekbang com</div>
           <script>
               console.log('time.geekbang.org')
           </script>
           <div>geekbang com</div>
       </body>
   </html>
   ```

   在执行 JavaScript 脚本之前，如果页面中包含了外部 CSS 文件的引用，或者通过 style 标签内置了 CSS 内容，那么渲染引擎还需要将这些内容转换为 CSSOM，因为 JavaScript 有修改 CSSOM 的能力，所以在执行 JavaScript 之前，还需要依赖 CSSOM。也就是说 CSS 在部分情况下也会阻塞 DOM 的生成。

   ![image.png](https://i.loli.net/2021/07/29/q2xVT17UHgbBku3.png)



3. 

   ```css
   /* theme.css */
   div{ 
       color : coral;
       background-color:black
   }
   ```

   ```js
   //foo.js
   console.log('time.geekbang.org')
   ```

   ```html
   <html>
       <head>
           <link href="theme.css" rel="stylesheet">
       </head>
       <body>
           <div>geekbang com</div>
           <script src='foo.js'></script>
           <div>geekbang com</div>
       </body>
   </html>
   ```

   在接收到 HTML 数据之后的预解析过程中，HTML 预解析器识别出来了有 CSS 文件和 JavaScript 文件需要下载，然后就同时发起这两个文件的下载请求，需要注意的是，这两个文件的下载过程是重叠的，所以下载时间按照最久的那个文件来算。

   <u>不管 CSS 文件和 JavaScript 文件谁先到达，都要先等到 CSS 文件下载完成并生成 CSSOM，然后再执行 JavaScript 脚本，最后再继续构建 DOM，构建布局树，绘制页面。</u>

   ![image.png](https://i.loli.net/2021/07/29/2mFaifV7RjltUgx.png)



从发起 URL 请求开始，到首次显示页面的内容，在视觉上经历的三个阶段。

- 第一个阶段，等请求发出去之后，到提交数据阶段，这时页面展示出来的还是之前页面的内容。
- 第二个阶段，提交数据之后渲染进程会创建一个空白页面，我们通常把这段时间称为**解析白屏**，并等待 CSS 文件和 JavaScript 文件的加载完成，生成 CSSOM 和 DOM，然后合成布局树，最后还要经过一系列的步骤准备首次渲染。
- 第三个阶段，等首次渲染完成之后，就开始进入完整页面的生成阶段了，然后页面会一点点被绘制出来。

---

缩短白屏时长，可以有以下策略：

- 通过内联 JavaScript、内联 CSS 来移除这两种类型的文件下载，这样获取到 HTML 文件之后就可以直接开始渲染流程了。
- 但并不是所有的场合都适合内联，那么还可以尽量减少文件大小，比如通过 webpack 等工具移除一些不必要的注释，并压缩 JavaScript 文件。
- 还可以将一些不需要在解析 HTML 阶段使用的 JavaScript 标记上 <u>async</u> 或者 <u>defer</u>。
- 对于大的 CSS 文件，可以通过媒体查询属性，将其拆分为多个不同用途的 CSS 文件，这样只有在特定的场景下才会加载特定的 CSS 文件。





## 24 | 分层和合成机制：为什么CSS动画比JavaScript高效？

**帧**：渲染流水线生成的每一副图片称为一帧

**帧率**：渲染流水线每秒更新了多少帧称为帧率（比如滚动过程中 1 秒更新了 60 帧，那么帧率就是 60Hz（或者 60FPS））

关于其中任意一帧的生成方式，有**重排、重绘**和**合成**三种方式。

这三种方式的渲染路径是不同的，**通常渲染路径越长，生成图像花费的时间就越多**。比如**重排**，它需要重新根据 CSSOM 和 DOM 来计算布局树，这样生成一幅图片时，会让整个渲染流水线的每个阶段都执行一遍，如果布局复杂的话，就很难保证渲染的效率了。而**重绘**因为没有了重新布局的阶段，操作效率稍微高点，但是依然需要重新计算绘制信息，并触发绘制操作之后的一系列操作。

相较于重排和重绘，**合成**操作的路径就显得非常短了，并不需要触发布局和绘制两个阶段，如果采用了 GPU，那么合成的效率会非常高

Chrome 中的合成技术，可以用三个词来概括总结：**分层、分块**和**合成**。

将素材分解为多个图层的操作就称为**分层**，最后将这些图层合并到一起的操作就称为**合成**。所以，分层和合成通常是一起使用的。

在 Chrome 的渲染流水线中，**分层体现在生成布局树之后**，渲染引擎会根据布局树的特点将其转换为层树（Layer Tree），层树是渲染流水线后续流程的基础结构。

层树中的每个节点都对应着一个图层，下一步的绘制阶段就依赖于层树中的节点。绘制阶段其实并不是真正地绘出图片，而是将绘制指令组合成一个列表，比如一个图层要设置的背景为黑色，并且还要在中间画一个圆形，那么绘制过程会生成`|Paint BackGroundColor:Black | Paint Circle|`这样的绘制指令列表，绘制过程就完成了。

有了绘制列表之后，就需要进入光栅化阶段了，<u>光栅化就是按照绘制列表中的指令生成图片</u>。每一个图层都对应一张图片，合成线程有了这些图片之后，会将这些图片合成为“一张”图片，并最终将生成的图片发送到后缓冲区。这就是一个大致的分层、合成流程。

**合成操作是在合成线程上完成的，这也就意味着在执行合成操作时，是不会影响到主线程执行的**。这就是为什么经常主线程卡住了，但是 CSS 动画依然能执行的原因。

**分块**：合成线程会将每个图层分割为大小固定的图块，然后优先绘制靠近视口的图块，这样就可以大大加速页面的显示速度。

使用 `will-change` 来告诉渲染引擎你会对该元素做一些特效变换，CSS 代码如下：

```css
.box {
    will-change: transform, opacity;
}
```

这段代码就是提前告诉渲染引擎 box 元素将要做几何变换和透明度变换操作，这时候渲染引擎会将该元素单独实现一帧，等这些变换发生时，渲染引擎会通过合成线程直接去处理变换，这些变换并没有涉及到主线程，这样就大大提升了渲染的效率。**这也是 CSS 动画比 JavaScript 动画高效的原因**。





## 25 | 页面性能：如何系统地优化页面？

通常一个页面有三个阶段：**加载阶段、交互阶段和关闭阶段**。

- 加载阶段，是指从发出请求到渲染出完整页面的过程，影响到这个阶段的主要因素有网络和 JavaScript 脚本。
- 交互阶段，主要是从页面加载完成到用户交互的整合过程，影响到这个阶段的主要因素是 JavaScript 脚本。
- 关闭阶段，主要是用户发出关闭指令后页面所做的一些清理操作。



**加载阶段**：

![image.png](https://i.loli.net/2021/07/29/n8W3bHeriZCcFNp.png)

图片、音频、视频等文件就不会阻塞页面的首次渲染；而 JavaScript、首次请求的 HTML 资源文件、CSS 文件是会阻塞首次渲染的，因为在构建 DOM 的过程中需要 HTML 和 JavaScript 文件，在构造渲染树的过程中需要用到 CSS 文件。

<u>这些能阻塞网页首次渲染的资源称为关键资源</u>

- **第一个是关键资源个数**。关键资源个数越多，首次页面的加载时间就会越长。比如上图中的关键资源个数就是 3 个，1 个 HTML 文件、1 个 JavaScript 和 1 个 CSS 文件。
- **第二个是关键资源大小**。通常情况下，所有关键资源的内容越小，其整个资源的下载时间也就越短，那么阻塞渲染的时间也就越短。上图中关键资源的大小分别是 6KB、8KB 和 9KB，那么整个关键资源大小就是 23KB。
- **第三个是请求关键资源需要多少个 RTT（Round Trip Time）**。当使用 TCP 协议传输一个文件时，比如这个文件大小是 0.1M，由于 TCP 的特性，这个数据并不是一次传输到服务端的，而是需要拆分成一个个数据包来回多次进行传输的。**RTT 就是这里的往返时延。它是网络中一个重要的性能指标，表示从发送端发送数据开始，到发送端收到来自接收端的确认，总共经历的时延**。<u>通常 1 个 HTTP 的数据包在 14KB 左右</u>，所以 1 个 0.1M 的页面就需要拆分成 8 个包来传输了，也就是说需要 8 个 RTT。

<u>总的优化原则就是减少关键资源个数，降低关键资源大小，降低关键资源的 RTT 次数。</u>

- <u>如何减少关键资源的个数？</u>一种方式是可以将 JavaScript 和 CSS 改成内联的形式，比如上图的 JavaScript 和 CSS，若都改成内联模式，那么关键资源的个数就由 3 个减少到了 1 个。另一种方式，如果 JavaScript 代码没有 DOM 或者 CSSOM 的操作，则可以改成 sync 或者 defer 属性；同样对于 CSS，如果不是在构建页面之前加载的，则可以添加媒体取消阻止显现的标志。当 JavaScript 标签加上了 sync 或者 defer、CSSlink 属性之前加上了取消阻止显现的标志后，它们就变成了非关键资源了。
- <u>如何减少关键资源的大小？</u>可以压缩 CSS 和 JavaScript 资源，移除 HTML、CSS、JavaScript 文件中一些注释内容，也可以通过前面讲的取消 CSS 或者 JavaScript 中关键资源的方式。
- <u>如何减少关键资源 RTT 的次数？</u>可以通过减少关键资源的个数和减少关键资源的大小搭配来实现。除此之外，还可以使用 CDN 来减少每次 RTT 时长。



**交互阶段**

交互阶段渲染流水线：

![image.png](https://i.loli.net/2021/07/29/ElwKeUjfoWxY8Za.png)

交互阶段渲染流水线中有哪些因素影响了帧的生成速度以及如何去优化：

1. **减少 JavaScript 脚本执行时间**

   有时 JavaScript 函数的一次执行时间可能有几百毫秒，这就严重霸占了主线程执行其他渲染任务的时间。针对这种情况我们可以采用以下两种策略：

- 一种是将一次执行的函数分解为多个任务，使得每次的执行时间不要过久。

- 另一种是采用 Web Workers。你可以把 Web Workers 当作主线程之外的一个线程，在 Web Workers 中是可以执行 JavaScript 脚本的，不过 Web Workers 中没有 DOM、CSSOM 环境，这意味着在 Web Workers 中是无法通过 JavaScript 来访问 DOM 的，所以我们可以把一些和 DOM 操作无关且耗时的任务放到 Web Workers 中去执行。

  <u>总之，在交互阶段，对 JavaScript 脚本总的原则就是不要一次霸占太久主线程。</u>

2. **避免强制同步布局**

   <u>强制同步布局，是指 JavaScript 强制将计算样式和布局操作提前到当前的任务中。</u>

   执行 JavaScript 添加元素是在一个任务中执行的，重新计算样式布局是在另外一个任务中执行。

   ```js
   function foo() {
       let main_div = document.getElementById("mian_div")
       let new_node = document.createElement("li")
       let textnode = document.createTextNode("time.geekbang")
       new_node.appendChild(textnode);
       document.getElementById("mian_div").appendChild(new_node);
       // 由于要获取到 offsetHeight，
       // 但是此时的 offsetHeight 还是老的数据，
       // 所以需要立即执行布局操作
       console.log(main_div.offsetHeight)
   }
   ```

   将新的元素添加到 DOM 之后，我们又调用了`main_div.offsetHeight`来获取新 main_div 的高度信息。如果要获取到 main_div 的高度，就需要重新布局，所以这里在获取到 main_div 的高度之前，JavaScript 还需要强制让渲染引擎默认执行一次布局操作。我们把这个操作称为强制同步布局。

   ![image.png](https://i.loli.net/2021/07/30/uzPtVNnwf2HMpGI.png)

   为了避免强制同步布局，我们可以调整策略，在修改 DOM 之前查询相关值。代码如下所示：

   ```js
   function foo() {
       let main_div = document.getElementById("mian_div")
       // 为了避免强制同步布局，在修改 DOM 之前查询相关值
       console.log(main_div.offsetHeight)
       let new_node = document.createElement("li")
       let textnode = document.createTextNode("time.geekbang")
       new_node.appendChild(textnode);
       document.getElementById("mian_div").appendChild(new_node);
   
   }
   ```

   

   

3. **避免布局抖动**

   <u>所谓布局抖动，是指在一次 JavaScript 执行过程中，多次执行强制布局和抖动操作。</u>

   ```js
   function foo() {
       let time_li = document.getElementById("time_li")
       for (let i = 0; i < 100; i++) {
           let main_div = document.getElementById("mian_div")
           let new_node = document.createElement("li")
           let textnode = document.createTextNode("time.geekbang")
           new_node.appendChild(textnode);
           new_node.offsetHeight = time_li.offsetHeight;
           document.getElementById("mian_div").appendChild(new_node);
       }
   }
   ```

   ![image.png](https://i.loli.net/2021/07/30/vMSjG1tiJ2gFRWI.png)

   从上图可以看出，在 foo 函数内部重复执行计算样式和布局，这会大大影响当前函数的执行效率。这种情况的避免方式和强制同步布局一样，都是尽量不要在修改 DOM 结构时再去查询一些相关值。

   

4. **合理利用 CSS 合成动画**

   合成动画是直接在合成线程上执行的，这和在主线程上执行的布局、绘制等操作不同，如果主线程被 JavaScript 或者一些布局任务占用，CSS 动画依然能继续执行。所以要尽量利用好 CSS 合成动画，如果能让 CSS 处理动画，就尽量交给 CSS 来操作。

5. **避免频繁的垃圾回收**

   JavaScript 使用了自动垃圾回收机制，如果在一些函数中频繁创建临时对象，那么垃圾回收器也会频繁地去执行垃圾回收策略。这样当垃圾回收操作发生时，就会占用主线程，从而影响到其他任务的执行，严重的话还会让用户产生掉帧、不流畅的感觉。



## 26 | 虚拟DOM：虚拟DOM和实际的DOM有何不同？

虚拟 DOM 执行流程：

![image.png](https://i.loli.net/2021/07/30/rfHAIYpGh3FozL5.png)

- **创建阶段**。首先依据 JSX 和基础数据创建出来虚拟 DOM，它反映了真实的 DOM 树的结构。然后由虚拟 DOM 树创建出真实 DOM 树，真实的 DOM 树生成完后，再触发渲染流水线往屏幕输出页面。
- **更新阶段**。如果数据发生了改变，那么就需要根据新的数据创建一个新的虚拟 DOM 树；然后 React 比较两个树，找出变化的地方，并把变化的地方一次性更新到真实的 DOM 树上；最后渲染引擎更新渲染流水线，并生成新的页面。



## 27 | 渐进式网页应用（PWA）：它究竟解决了Web应用的哪些问题？

<u>PWA</u>，全称是 Progressive Web App，翻译过来就是渐进式网页应用。根据字面意思，它就是“渐进式 +Web 应用”。对于 Web 应用很好理解了，就是目前我们普通的 Web 页面，所以 PWA 所支持的首先是一个 Web 页面。

**什么是 Service Worker**：它的主要思想是<u>在页面和网络之间增加一个拦截器，用来缓存和拦截请求</u>

![image.png](https://i.loli.net/2021/07/30/lGdcCvUm6MezAEb.png)

在没有安装 Service Worker 之前，WebApp 都是直接通过网络模块来请求资源的。安装了 Service Worker 模块之后，WebApp 请求资源时，会先通过 Service Worker，让它判断是返回 Service Worker 缓存的资源还是重新去网络请求资源。一切的控制权都交由 Service Worker 来处理。





## 28 | WebComponent：像搭积木一样构建Web应用

那什么是组件化呢？

其实组件化并没有一个明确的定义，不过这里我们可以使用 10 个字来形容什么是组件化，那就是：**对内高内聚，对外低耦合**。对内各个元素彼此紧密结合、相互依赖，对外和其他组件的联系最少且接口简单。



**WebComponent 组件化开发**

WebComponent 给出了解决思路，它提供了对局部视图封装能力，可以让 DOM、CSSOM 和 JavaScript 运行在局部环境中，这样就使得局部的 CSS 和 DOM 不会影响到全局。

WebComponent 是一套技术的组合，具体涉及到了**Custom elements（自定义元素）、Shadow DOM（影子 DOM）和 HTML templates（HTML 模板）**

```html
<!DOCTYPE html>
<html>
    <body>
        <!--
            一：定义模板
            二：定义内部 CSS 样式
            三：定义 JavaScript 行为
        -->
        <template id="geekbang-t">
            <style>
                p {
                    background-color: brown;
                    color: cornsilk;
                }

                div {
                    width: 200px;
                    background-color: bisque;
                    border: 3px solid chocolate;
                    border-radius: 10px;
                }
            </style>
            <div>
                <p>time.geekbang.org</p>
                <p>time1.geekbang.org</p>
            </div>
            <script>
                function foo() {
                    console.log('inner log');
                }
            </script>
        </template>
        <script>
            class GeekBang extends HTMLElement {
                constructor() {
                    super();
                    // 获取组件模板
                    const content = document.querySelector('#geekbang-t').content;
                    // 创建影子 DOM 节点
                    const shadowDOM = this.attachShadow({ mode: 'open' });
                    // 将模板添加到影子 DOM 上
                    shadowDOM.appendChild(content.cloneNode(true));
                }
            }
            customElements.define('geek-bang', GeekBang);
        </script>

        <geek-bang></geek-bang>
        <div>
            <p>time.geekbang.org</p>
            <p>time1.geekbang.org</p>
        </div>
        <geek-bang></geek-bang>
    </body>
</html>

```



**影子 DOM 的作用主要有以下两点**：

1. 影子 DOM 中的元素对于整个网页是不可见的；
2. 影子 DOM 的 CSS 不会影响到整个网页的 CSSOM，影子 DOM 内部的 CSS 只对内部的元素起作用。





## 29 | HTTP/1：HTTP性能优化

**超文本传输协议 HTTP/0.9**：HTTP/0.9 是于 1991 年提出的，主要用于学术交流，需求很简单——用来在网络之间传递 HTML 超文本的内容。

- HTTP/0.9 的实现有以下三个特点。

  - 第一个是只有一个请求行，并没有**HTTP 请求头和请求体**，因为只需要一个请求行就可以完整表达客户端的需求了。
  - 第二个是服务器也没有返回头信息，这是因为服务器端并不需要告诉客户端太多信息，只需要返回数据就可以了。
  - 第三个是返回的文件内容是以 ASCII 字符流来传输的，因为都是 HTML 格式的文件，所以使用 ASCII 字节码来传输是最合适的。

  ![image.png](https://i.loli.net/2021/07/30/4XQ7kq93GhudvWJ.png)




**HTTP/1.0**

HTTP/1.0 引入了<u>请求头</u>和<u>响应头</u>，它们都是以为 <u>Key-Value</u> 形式保存的，在 HTTP 发送请求时，会带上请求头信息，服务器返回数据时，会先返回响应头信息。

新增的几个典型的特性：

- 有的请求服务器可能无法处理，或者处理出错，这时候就需要告诉浏览器服务器最终处理该请求的情况，这就引入了**状态码**。状态码是通过响应行的方式来通知浏览器的。
- 为了减轻服务器的压力，在 HTTP/1.0 中提供了**Cache 机制**，用来缓存已经下载过的数据。
- 服务器需要统计客户端的基础信息，比如 Windows 和 macOS 的用户数量分别是多少，所以 HTTP/1.0 的请求头中还加入了**用户代理**的字段。



**HTTP/1.1**

1. **改进持久连接**

   <u>HTTP/1.1 中增加了持久连接的方法，它的特点是在一个 TCP 连接上可以传输多个 HTTP 请求，只要浏览器或者服务器没有明确断开连接，那么该 TCP 连接会一直保持。</u>

![image.png](https://i.loli.net/2021/07/30/6ctLyjTXQO7mr9S.png)

- HTTP 的持久连接可以有效减少 TCP 建立连接和断开连接的次数，这样的好处是减少了服务器额外的负担，并提升整体 HTTP 的请求时长。
- **持久连接在 HTTP/1.1 中是默认开启的**，所以你不需要专门为了持久连接去 HTTP 请求头设置信息，如果你不想要采用持久连接，可以在 HTTP 请求头中加上`Connection: close`。**目前浏览器中对于同一个域名，默认允许同时建立 6 个 TCP 持久连接**。



2. **不成熟的 HTTP 管线化**

   持久连接虽然能减少 TCP 的建立和断开次数，但是它需要等待前面的请求返回之后，才能进行下一次请求。如果 TCP 通道中的某个请求因为某些原因没有及时返回，那么就会阻塞后面的所有请求，这就是著名的**队头阻塞**的问题。

   HTTP/1.1 中试图通过管线化的技术来解决**队头阻塞**的问题。HTTP/1.1 中的管线化是指将多个 HTTP 请求整批提交给服务器的技术，虽然可以整批发送请求，不过服务器依然需要根据请求顺序来回复浏览器的请求。

   FireFox、Chrome 都做过管线化的试验，但是由于各种原因，它们最终都放弃了管线化技术。

   

3. **提供虚拟主机的支持**

   在 HTTP/1.0 中，每个域名绑定了一个唯一的 IP 地址，因此一个服务器只能支持一个域名。但是随着虚拟主机技术的发展，需要实现在一台物理主机上绑定多个虚拟主机，每个虚拟主机都有自己的单独的域名，这些单独的域名都公用同一个 IP 地址。

   HTTP/1.1 的请求头中增加了**Host 字段**，用来表示当前的域名地址，这样服务器就可以根据不同的 Host 值做不同的处理。

4. **对动态生成的内容提供了完美支持**

   在设计 HTTP/1.0 时，需要在响应头中设置完整的数据大小，如`Content-Length: 901`，这样浏览器就可以根据设置的数据大小来接收数据。不过随着服务器端的技术发展，很多页面的内容都是动态生成的，因此在传输数据之前并不知道最终的数据大小，这就导致了浏览器不知道何时会接收完所有的文件数据。

   HTTP/1.1 通过引入**Chunk transfer 机制**来解决这个问题，服务器会将数据分割成若干个任意大小的数据块，每个数据块发送时会附上上个数据块的长度，最后使用一个零长度的块作为发送数据完成的标志。这样就提供了对动态内容的支持。

5. **客户端 Cookie、安全机制**

   HTTP/1.1 还引入了客户端 Cookie 机制和安全机制。





## 30｜HTTP/2：如何提升网络速度？

**带宽是指每秒最大能发送或者接收的字节数**。我们把每秒能发送的最大字节数称为**上行带宽**，每秒能够接收的最大字节数称为**下行带宽**。

**HTTP/1.1 的主要问题**：

1. <u>TCP 的慢启动</u>。一旦一个 TCP 连接建立之后，就进入了发送数据状态，刚开始 TCP 协议会采用一个非常慢的速度去发送数据，然后慢慢加快发送数据的速度，直到发送数据的速度达到一个理想状态，我们把这个过程称为慢启动。

2. <u>同时开启了多条 TCP 连接，那么这些连接会竞争固定的带宽</u>。系统同时建立了多条 TCP 连接，当带宽充足时，每条连接发送或者接收速度会慢慢向上增加；而一旦带宽不足时，这些 TCP 连接又会减慢发送或者接收的速度。

3. <u>HTTP/1.1 队头阻塞的问题</u>。在 HTTP/1.1 中使用持久连接时，虽然能公用一个 TCP 管道，但是在一个管道中同一时刻只能处理一个请求，在当前的请求没有结束之前，其他的请求只能处于阻塞状态。这意味着我们不能随意在一个管道中发送请求和接收内容。

   

**HTTP/2 的多路复用**

<u>慢启动和 TCP 连接之间相互竞争带宽是由于 TCP 本身的机制导致的，而队头阻塞是由于 HTTP/1.1 的机制导致的。</u>

HTTP/2 的思路就是一个域名只使用一个 TCP 长连接来传输数据，这样整个页面资源的下载过程只需要一次慢启动，同时也避免了多个 TCP 连接竞争带宽所带来的问题。

另外，就是队头阻塞的问题，等待请求完成后才能去请求下一个资源，这种方式无疑是最慢的，所以 HTTP/2 需要实现资源的并行请求，也就是任何时候都可以将请求发送给服务器，而并不需要等待其他请求的完成，然后服务器也可以随时返回处理好的请求资源给浏览器。

<u>**一个域名只使用一个 TCP 长连接和消除队头阻塞问题**</u>

![image.png](https://i.loli.net/2021/07/30/RYVEQAIKDN1m4bg.png)

该图就是 HTTP/2 最核心、最重要且最具颠覆性的**多路复用机制**。从图中你会发现每个请求都有一个对应的 ID，如 stream1 表示 index.html 的请求，stream2 表示 foo.css 的请求。这样在浏览器端，就可以随时将请求发送给服务器了。

服务器端接收到这些请求后，会根据自己的喜好来决定优先返回哪些内容，比如服务器可能早就缓存好了 index.html 和 bar.js 的响应头信息，那么当接收到请求的时候就可以立即把 index.html 和 bar.js 的响应头信息返回给浏览器，然后再将 index.html 和 bar.js 的响应体数据返回给浏览器。之所以可以随意发送，是因为每份数据都有对应的 ID，浏览器接收到之后，会筛选出相同 ID 的内容，将其拼接为完整的 HTTP 响应数据。

HTTP/2 使用了多路复用技术，可以将请求分成一帧一帧的数据去传输，这样带来了一个额外的好处，就是当收到一个优先级高的请求时，比如接收到 JavaScript 或者 CSS 关键资源的请求，服务器可以暂停之前的请求来优先处理关键资源的请求。



**多路复用的实现**：

![image.png](https://i.loli.net/2021/07/30/hcitP35ZWLklgOa.png)

HTTP/2 添加了一个**二进制分帧层**：

- 首先，浏览器准备好请求数据，包括了请求行、请求头等信息，如果是 POST 方法，那么还要有请求体。
- 这些数据经过二进制分帧层处理之后，会被转换为一个个带有请求 ID 编号的帧，通过协议栈将这些帧发送给服务器。
- 服务器接收到所有帧之后，会将所有相同 ID 的帧合并为一条完整的请求信息。
- 然后服务器处理该条请求，并将处理的响应行、响应头和响应体分别发送至二进制分帧层。
- 同样，二进制分帧层会将这些响应数据转换为一个个带有请求 ID 编号的帧，经过协议栈发送给浏览器。
- 浏览器接收到响应帧之后，会根据 ID 编号将帧的数据提交给对应的请求。

<u>通过引入二进制分帧层，就实现了 HTTP 的多路复用技术</u>



**HTTP/2 其他特性**：

1. **可以设置请求的优先级**

   HTTP/2 提供了请求优先级，可以在发送请求时，标上该请求的优先级，这样服务器接收到请求之后，会优先处理优先级高的请求。

2. **服务器推送**

   HTTP/2 还可以直接将数据提前推送到浏览器

3. **头部压缩**

   HTTP/2 对请求头和响应头进行了压缩



## 31｜HTTP/3：甩掉TCP、TLS 的包袱，构建高效网络

<u>HTTP/2 解决了应用层面的队头阻塞问题</u>（无法解决 TCP 的队头阻塞）

**TCP 的队头阻塞**

正常情况下的 TCP 传输数据过程：

![image.png](https://i.loli.net/2021/07/30/Qy1eIzHr3bl8fnm.png)

一端发送给另外一端的数据会被拆分为一个个按照顺序排列的数据包，这些数据包通过网络传输到了接收端，接收端再按照顺序将这些数据包组合成原始数据，这样就完成了数据传输。

<u>如果在数据传输的过程中，有一个数据因为网络故障或者其他原因而丢包了，那么整个 TCP 的连接就会处于暂停状态，需要等待丢失的数据包被重新传输过来。</u>

**在 TCP 传输过程中，由于单个数据包的丢失而造成的阻塞称为 TCP 上的队头阻塞**。



HTTP/2 多路复用：

![image.png](https://i.loli.net/2021/07/30/7YEtJscryS1vTp9.png)

在 HTTP/2 中，多个请求是跑在一个 TCP 管道中的，如果其中任意一路数据流中出现了丢包的情况，那么就会阻塞该 TCP 连接中的所有请求。

这不同于 HTTP/1.1，使用 HTTP/1.1 时，浏览器为每个域名开启了 6 个 TCP 连接，如果其中的 1 个 TCP 连接发生了队头阻塞，那么其他的 5 个连接依然可以继续传输数据。



**TCP 建立连接的延时**

1. 在建立 TCP 连接的时候，需要和服务器进行三次握手来确认连接成功，也就是说需要在消耗完 1.5 个 RTT 之后才能进行数据传输。
2. 进行 TLS 连接，TLS 有两个版本——TLS1.2 和 TLS1.3，每个版本建立连接所花的时间不同，大致是需要 1～2 个 RTT，关于 HTTPS 我们到后面到安全模块再做详细介绍。

<u>总之，在传输数据之前，我们需要花掉 3～4 个 RTT。</u>



**QUIC 协议**

HTTP/3 选择了一个折衷的方法——UDP 协议，基于 UDP 实现了类似于 TCP 的多路数据流、传输可靠性等功能，我们把这套功能称为**QUIC 协议**。

![image.png](https://i.loli.net/2021/07/30/5Iq4MLaecr3xtBf.png)

HTTP/3 中的 QUIC 协议集合了以下几点功能：

- **实现了类似 TCP 的流量控制、传输可靠性的功能**。虽然 UDP 不提供可靠性的传输，但 QUIC 在 UDP 的基础之上增加了一层来保证数据可靠性传输。它提供了数据包重传、拥塞控制以及其他一些 TCP 中存在的特性。
- **集成了 TLS 加密功能**。目前 QUIC 使用的是 TLS1.3，相较于早期版本 TLS1.3 有更多的优点，其中最重要的一点是减少了握手所花费的 RTT 个数。
- **实现了 HTTP/2 中的多路复用功能**。和 TCP 不同，QUIC 实现了在同一物理连接上可以有多个独立的逻辑数据流（如下图）。实现了数据流的单独传输，就解决了 TCP 中队头阻塞的问题。

![image.png](https://i.loli.net/2021/07/30/pD4nR8qFKMfJWsV.png)

- **实现了快速握手功能**。由于 QUIC 是基于 UDP 的，所以 QUIC 可以实现使用 0-RTT 或者 1-RTT 来建立连接，这意味着 QUIC 可以用最快的速度来发送和接收数据，这样可以大大提升首次打开页面的速度。



## 32 | 同源策略：为什么XMLHttpRequest不能跨域请求资源？

**同源策略**：协议、域名和端口都相同。

具体来讲，同源策略主要表现在 DOM、Web 数据和网络这三个层面。

1. **DOM 层面**。同源策略限制了来自不同源的 JavaScript 脚本对当前 DOM 对象读和写的操作。
2. **数据层面**。同源策略限制了不同源的站点读取当前站点的 Cookie、IndexDB、LocalStorage 等数据。由于同源策略，我们依然无法通过第二个页面的 opener 来访问第一个页面中的 Cookie、IndexDB 或者 LocalStorage 等内容。
3. **网络层面**。同源策略限制了通过 XMLHttpRequest 等方式将站点的数据发送给不同源的站点。



为了解决 XSS 攻击，浏览器中引入了内容安全策略，称为 CSP。**CSP 的核心思想是让服务器决定浏览器能够加载哪些资源，让服务器决定浏览器是否能够执行内联 JavaScript 代码**

总结：

1. 页面中可以引用第三方资源，不过这也暴露了很多诸如 XSS 的安全问题，因此又在这种开放的基础之上引入了 CSP 来限制其自由程度。
2. 使用 XMLHttpRequest 和 Fetch 都是无法直接进行跨域请求的，因此浏览器又在这种严格策略的基础之上引入了跨域资源共享策略，让其可以安全地进行跨域操作。
3. 两个不同源的 DOM 是不能相互操纵的，因此，浏览器中又实现了跨文档消息机制，让其可以比较安全地通信。



## 33 | 跨站脚本攻击（XSS）：为什么Cookie中有HttpOnly属性？

**XSS** 全称是 `Cross Site Scripting`，为了与“CSS”区分开来，故简称 XSS，翻译过来就是“跨站脚本”。

<u>XSS 攻击是指黑客往 HTML 文件中或者 DOM 中注入恶意脚本，从而在用户浏览页面时利用注入的恶意脚本对用户实施攻击的一种手段。</u>

- 可以**窃取 Cookie 信息**。恶意 JavaScript 可以通过“document.cookie”获取 Cookie 信息，然后通过 XMLHttpRequest 或者 Fetch 加上 CORS 功能将数据发送给恶意服务器；恶意服务器拿到用户的 Cookie 信息之后，就可以在其他电脑上模拟用户的登录，然后进行转账等操作。
- 可以**监听用户行为**。恶意 JavaScript 可以使用“addEventListener”接口来监听键盘事件，比如可以获取用户输入的信用卡等信息，将其发送到恶意服务器。黑客掌握了这些信息之后，又可以做很多违法的事情。
- 可以通过**修改 DOM**伪造假的登录窗口，用来欺骗用户输入用户名和密码等信息。
- 还可以**在页面内生成浮窗广告**，这些广告会严重地影响用户体验。

通常情况下，主要有**存储型 XSS 攻击、反射型 XSS 攻击**和**基于 DOM 的 XSS 攻击**三种方式来注入恶意脚本。

1. **存储型 XSS 攻击**
   - 首先黑客利用站点漏洞将一段恶意 JavaScript 代码提交到网站的数据库中；
   - 然后用户向网站请求包含了恶意 JavaScript 脚本的页面；
   - 当用户浏览该页面的时候，恶意脚本就会将用户的 Cookie 信息等数据上传到服务器。

2. **反射型 XSS 攻击**

   在一个反射型 XSS 攻击过程中，恶意 JavaScript 脚本属于用户发送给网站请求中的一部分，随后网站又把恶意 JavaScript 脚本返回给用户。当恶意 JavaScript 脚本在用户页面中被执行时，黑客就可以利用该脚本做一些恶意操作。

   **Web 服务器不会存储反射型 XSS 攻击的恶意脚本，这是和存储型 XSS 攻击不同的地方**。

3. **基于 DOM 的 XSS 攻击**

   基于 DOM 的 XSS 攻击是不牵涉到页面 Web 服务器的。具体来讲，黑客通过各种手段将恶意脚本注入用户的页面中，比如通过网络劫持在页面传输过程中修改 HTML 页面的内容，这种劫持类型很多，有通过 WiFi 路由器劫持的，有通过本地恶意软件来劫持的，它们的共同点是在 Web 资源传输过程或者在用户使用页面的过程中修改 Web 页面的数据。

   

**如何阻止 XSS 攻击**

1. 服务器对输入脚本进行过滤或转码

2. 充分利用 CSP（`Content-Security-Policy`）

   - 限制加载其他域下的资源文件，这样即使黑客插入了一个 JavaScript 文件，这个 JavaScript 文件也是无法被加载的；
   - 禁止向第三方域提交数据，这样用户数据也不会外泄；
   - 禁止执行内联脚本和未授权的脚本；
   - 还提供了上报机制，这样可以帮助我们尽快发现有哪些 XSS 攻击，以便尽快修复问题。

3. 使用 HttpOnly 属性

   使用 HttpOnly 标记的 Cookie 只能使用在 HTTP 请求过程中，所以无法通过 JavaScript 来读取这段 Cookie。

   由于 JavaScript 无法读取设置了 HttpOnly 的 Cookie 数据，所以即使页面被注入了恶意 JavaScript 脚本，也是无法获取到设置了 HttpOnly 的数据。



## 34 | CSRF攻击：陌生链接不要随便点

**CSRF 攻击**：CSRF 英文全称是 `Cross-site request forgery`，所以又称为“跨站请求伪造”，是指黑客引诱用户打开黑客的网站，在黑客的网站中，利用用户的登录状态发起的跨站请求。简单来讲，**CSRF 攻击就是黑客利用了用户的登录状态，并通过第三方的站点来做一些坏事**。

**和 XSS 不同的是，CSRF 攻击不需要将恶意代码注入用户的页面，仅仅是利用服务器的漏洞和用户的登录状态来实施攻击**。



**如何防止 CSRF 攻击**

1. **充分利用好 Cookie 的 SameSite 属性**

   SameSite 选项通常有 Strict、Lax 和 None 三个值：

   - Strict 最为严格。如果 SameSite 的值是 Strict，那么浏览器会完全禁止第三方 Cookie。简言之，如果你从极客时间的页面中访问 InfoQ 的资源，而 InfoQ 的某些 Cookie 设置了 SameSite = Strict 的话，那么这些 Cookie 是不会被发送到 InfoQ 的服务器上的。只有你从 InfoQ 的站点去请求 InfoQ 的资源时，才会带上这些 Cookie。

   - Lax 相对宽松一点。在跨站点的情况下，从第三方站点的链接打开和从第三方站点提交 Get 方式的表单这两种方式都会携带 Cookie。但如果在第三方站点中使用 Post 方法，或者通过 img、iframe 等标签加载的 URL，这些场景都不会携带 Cookie。

   - 而如果使用 None 的话，在任何情况下都会发送 Cookie 数据。

2. **验证请求的来源站点**

   利用 HTTP 请求头中的 `Referer` 和 `Origin` 属性

   **Referer 是 HTTP 请求头中的一个字段，记录了该 HTTP 请求的来源地址**。

   **Origin 属性只包含了域名信息，并没有包含具体的 URL 路径**

   服务器的策略是优先判断 Origin，如果请求头中没有包含 Origin 属性，再根据实际情况判断是否使用 Referer 值。

3. **CSRF Token**

   1. 第一步，在浏览器向服务器发起请求时，服务器生成一个 CSRF Token。CSRF Token 其实就是服务器生成的字符串，然后将该字符串植入到返回的页面中。

   2. 第二步，在浏览器端如果要发起转账的请求，那么需要带上页面中的 CSRF Token，然后服务器会验证该 Token 是否合法。如果是从第三方站点发出的请求，那么将无法获取到 CSRF Token 的值，所以即使发出了请求，服务器也会因为 CSRF Token 不正确而拒绝请求。



## 35 | 安全沙箱：页面和系统之间的隔离墙

浏览器内核和渲染进程：

![image.png](https://i.loli.net/2021/08/04/dq57EPpM8XYnUDu.png)

浏览器被划分为**浏览器内核**和**渲染内核**两个核心模块，其中浏览器内核是由网络进程、浏览器主进程和 GPU 进程组成的，渲染内核就是渲染进程。

所有的网络资源都是通过浏览器内核来下载的，下载后的资源会通过 IPC 将其提交给渲染进程（<u>浏览器内核和渲染进程之间都是通过 IPC 来通信的</u>）。然后渲染进程会对这些资源进行解析、绘制等操作，最终生成一幅图片。但是渲染进程并不负责将图片显示到界面上，而是将最终生成的图片提交给浏览器内核模块，由浏览器内核模块负责显示这张图片。

**渲染进程和操作系统隔离的这道墙就是安全沙箱**

浏览器中的安全沙箱是利用操作系统提供的安全技术，让渲染进程在执行过程中无法访问或者修改操作系统中的数据，在渲染进程需要访问系统资源的时候，需要通过浏览器内核来实现，然后将访问的结果通过 IPC 转发给渲染进程。

安全沙箱最小的保护单位是进程，这个进程必须没有读写操作系统的功能，比如读写本地文件、发起网络请求、调用 GPU 接口等。

浏览器内核和渲染进程各自职责：

![image.png](https://i.loli.net/2021/08/04/tHRiCneKxr2ZX1V.png)



## 36 | HTTPS：让数据传输更安全

HTTP VS HTTPS：

![image.png](https://i.loli.net/2021/08/05/JH1NOgc2GAQB4qa.png)

HTTPS 并非是一个新的协议，通常 HTTP 直接和 TCP 通信，HTTPS 则先和安全层通信，然后安全层再和 TCP 层通信。也就是说 HTTPS 所有的安全核心都在安全层，它不会影响到上面的 HTTP 协议，也不会影响到下面的 TCP/IP。

安全层有两个主要的职责：**对发起 HTTP 请求的数据进行加密操作**和**对接收到 HTTP 的内容进行解密操作**。

**第一版：使用对称加密**

<u>对称加密是指加密和解密都使用的是相同的密钥。</u>

![image.png](https://i.loli.net/2021/08/05/Lb5mMKyUctsfzoW.png)

- 浏览器发送它所支持的加密套件列表和一个随机数 client-random，这里的**加密套件是指加密的方法**，加密套件列表就是指浏览器能支持多少种加密方法列表。
- 服务器会从加密套件列表中选取一个加密套件，然后还会生成一个随机数 service-random，并将 service-random 和加密套件列表返回给浏览器。
- 最后浏览器和服务器分别返回确认消息。

**第二版：使用非对称加密**

<u>非对称加密算法有 A、B 两把密钥，如果你用 A 密钥来加密，那么只能使用 B 密钥来解密；反过来，如果你要 B 密钥来加密，那么只能用 A 密钥来解密。</u>

在 HTTPS 中，服务器会将其中的一个密钥通过明文的形式发送给浏览器，我们把这个密钥称为**公钥**，服务器自己留下的那个密钥称为**私钥**。顾名思义，**公钥是每个人都能获取到的，而私钥只有服务器才能知道，不对任何人公开**。

![image.png](https://i.loli.net/2021/08/05/6QfjhMUJRCFdq9W.png)

- 首先浏览器还是发送加密套件列表给服务器。
- 然后服务器会选择一个加密套件，不过和对称加密不同的是，使用非对称加密时服务器上需要有用于浏览器加密的公钥和服务器解密 HTTP 数据的私钥，由于公钥是给浏览器加密使用的，因此服务器会将加密套件和公钥一道发送给浏览器。
- 最后就是浏览器和服务器返回确认消息。

**第三版：对称加密和非对称加密搭配使用**

<u>在传输数据阶段依然使用对称加密，但是对称加密的密钥我们采用非对称加密来传输</u>

![image.png](https://i.loli.net/2021/08/05/NE4kvA1HysQLCgP.png)

- 首先浏览器向服务器发送对称加密套件列表、非对称加密套件列表和随机数 client-random；
- 服务器保存随机数 client-random，选择对称加密和非对称加密的套件，然后生成随机数 service-random，向浏览器发送选择的加密套件、service-random 和公钥；
- 浏览器保存公钥，并利用 client-random 和 service-random 计算出来 pre-master，然后利用公钥对 pre-master 加密，并向服务器发送加密后的数据；
- 最后服务器拿出自己的私钥，解密出 pre-master 数据，并返回确认消息。

**第四版：添加数字证书**

对于浏览器来说，数字证书有两个作用：一个是通过数字证书向浏览器证明服务器的身份，另一个是数字证书里面包含了服务器公钥。

![image.png](https://i.loli.net/2021/08/05/1qgS7uz4ty6Cksc.png)

相较于第三版的 HTTPS 协议，这里主要有两点改变：

1. 服务器没有直接返回公钥给浏览器，而是返回了数字证书，而公钥正是包含在数字证书中的；
2. 在浏览器端多了一个证书验证的操作，验证了证书之后，才继续后续流程。
